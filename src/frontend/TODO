- Macro expander
- Bypass values
  - prepare, provide, unprovide, ask, askvalue (with index match)
- ondone blocks (like onkill) and support in backend
  - ondone and onkill are codegen'd only once. The kill block is jumped to by
    all kill points. The done block is placed at the end of the 'main spur'.
- onkillyounger and support in the backend
  - codegen'd only once; jumped to by all killyounger points.
- Multiple-writer semantics
  - all writes to a port, chan, reg must be in the same timing stage
  - arbitration is by an arbitrary order (well-defined results only when all
    writes are mutually exclusive)
    - TODO: How does this interact with onkill/ondone? These should take higher
      priority in general, and be exempt from 'same stage'.
  - writes to an array are slightly different: each write implies a separate
    write port.
- STMTBLOCK exprs via 'expr { ... }'.
- support for defining new toplevels inside other funcs, while getting access
  to arrays/ports (with dynamic scope)
  - new statement type: anonymous func. Codegen must use same context, stash
    away CurBB and start a new one.


OoO-decomposed-as-macros:
- transactional state macros (or primitives?)
- queue! macro
- superscalar primitive? (alters the pipelining transform)
  - this needs to interact with the transactional-state primitives, produces a
    "channel mask" that indicates when lower ways are invalidated by
    dependences on upper ways, and wraps the pipe in a restart-loop to restart
    partway through superscalar groups.
  - Can we do this with a tweak to ask/provide? Superscalar bypass in a single
    cycle is like bypass over time in a scalar pipe; so bypass in a 4-way
    machine is like saying "next 3 ops can't bypass this value". Can 'ask' be
    tweaked to have a 'not available yet' status? This also allows for natural
    stall insertion in other cases if we have separate 'generate' and 'provide'
    ops -- 'generate' starts its scope (to close the danger window and force
    stalls on dependents) and 'provide' actually yields the value to
    dependents.
- rename! macro
- scoreboard-scheduler component or macro
  (a standard OoO backend is scoreboard scheduling composed with renaming)

Far-off goals:
- proper lexical scope and non-hacky function inlining
- rework the AST as either protobufs or (maybe) something more
  custom/lighter-weight with explicit visitor support
- rewrite the whole thing now that I understand the problem space better
  (leading candidate: Haskell DSL -- the Autopiper monad)
